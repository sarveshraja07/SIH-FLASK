<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Simulation - AI Train Safety</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; margin: 0; background: #f9fafb; }
        nav { background:#2563eb; padding:15px; color:white; display:flex; justify-content:space-between; }
        nav ul { list-style:none; display:flex; gap:20px; margin:0; padding:0; }
        nav ul li a { color:white; text-decoration:none; font-weight:600; }
        .container { max-width:1000px; margin:40px auto; padding:20px; background:white; border-radius:10px; box-shadow:0 2px 8px rgba(0,0,0,0.1); }
        h1, h2 { color:#111827; }
        form { margin-bottom:20px; }
        label { font-weight:600; }
        button { background:#2563eb; color:white; border:none; padding:10px 15px; border-radius:5px; font-weight:600; cursor:pointer; }
        button:hover { background:#1e4fd1; }
    </style>
</head>
<body>
    <nav>
    <ul>
        <li><a href="/" class="{% if request.path == '/' %}active{% endif %}">Home</a></li>
        <li><a href="/simulation" class="{% if request.path == '/simulation' %}active{% endif %}">Simulation</a></li>
        <li><a href="/info" class="{% if request.path == '/info' %}active{% endif %}">Information</a></li>
        <li><a href="/about" class="{% if request.path == '/about' %}active{% endif %}">About</a></li>
    </ul>
</nav>

    <div class="container">
        <h1>AI Train Safety Simulation</h1>

        <form method="POST" action="/simulation">
            <label for="num_trains">Enter number of trains:</label>
            <input type="number" id="num_trains" name="num_trains" min="2" max="10" required>
            <button type="submit">Start Simulation</button>
        </form>

        {% if initial_trains %}
        <h2>Initial Conditions:</h2>
        <ul>
            {% for train in initial_trains %}
            <li>Train-{{ train.id }}: Position = {{ "%.2f"|format(train.position) }} m, Speed = {{ "%.2f"|format(train.speed * 3.6) }} km/h</li>
            {% endfor %}
        </ul>
        {% endif %}

        {% if history_no_ai %}
        <h2>Results Without AI (Actual Collisions)</h2>
        <div id="plot-no-ai" style="height:460px;"></div>
        {% endif %}

        {% if history_prediction %}
        <h2>Results With AI - Prediction (Before Action)</h2>
        <div id="plot-ai-prediction" style="height:460px;"></div>
        {% endif %}

        {% if history_prevention %}
        <h2>Results With AI - After Action</h2>
        <div id="plot-ai-prevention" style="height:460px;"></div>
        {% endif %}
    </div>

<script>
/* ---------- Helpers ---------- */
function svgDot(color = "orange", size = 20) {
    const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='${size}' height='${size}'><circle cx='${size/2}' cy='${size/2}' r='${size/2}' fill='${color}'/></svg>`;
    return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
}

/* ---------- animateGraph ----------
history: { "1": [pos0,pos1,...], "2": [...] }
collisions: [ [time, position], ... ]
aiActions: [ [time, trainId, old_speed, new_speed, pos_at_time], ... ]
*/
function animateGraph(containerId, history, collisions=[], aiActions=[], title="") {
    // sort train ids numerically so order is stable
    const trainIds = Object.keys(history).sort((a,b) => Number(a) - Number(b));
    if (trainIds.length === 0) return;
    const maxSteps = history[trainIds[0]].length;

    // create empty traces (one per train)
    const traces = trainIds.map(tid => ({ x: [], y: [], mode: "lines", line: { width: 2 }, name: `Train ${tid}` }));

    Plotly.newPlot(containerId, traces, {
        title: title,
        xaxis: { title: "Time Step", range: [0, maxSteps] },
        yaxis: { title: "Position (m)" },
        margin: { t: 60 },
        showlegend: true,
        images: [],
        annotations: []
    });

    // group ai actions by train and sort by time
    const grouped = {};
    (aiActions || []).forEach(a => {
        const tid = String(a[1]);
        if (!grouped[tid]) grouped[tid] = [];
        grouped[tid].push(a);
    });
    Object.keys(grouped).forEach(tid => grouped[tid].sort((x,y) => x[0] - y[0]));

    // picks: first, middle, last per train (these are the pick events)
    const picks = {};
    Object.keys(grouped).forEach(tid => {
        const acts = grouped[tid];
        if (!acts || acts.length === 0) return;
        const sel = [acts[0]];
        if (acts.length > 2) sel.push(acts[Math.floor(acts.length/2)]);
        if (acts.length > 1) sel.push(acts[acts.length - 1]);
        picks[tid] = sel;
    });

    // we'll keep cumulative annotations so already-shown annotations stay visible
    const cumulativeAnnotations = [];

    // used to avoid re-adding same pick annotation
    const pickShown = {};

    // action start entries: activate moving orange dot at the action time
    const actionStarts = (aiActions || []).map((a, idx) => ({ id: idx, start: Number(a[0]), trainId: String(a[1]), info: a }));

    const activeDots = []; // active moving orange dots
    const collisionMap = {};
    (collisions || []).forEach(c => {
        const time = Number(c[0]);
        if (!collisionMap[time]) collisionMap[time] = [];
        collisionMap[time].push(c[1]);
    });

    // bigger vertical offsets to reduce overlap (tweak magnitude if needed)
    const yOffsets = {};
    trainIds.forEach((tid, idx) => {
        const sign = (idx % 2 === 0) ? 1 : -1;
        const magnitude = 3.0 * Math.floor(idx / 2); // 3 meters per step
        yOffsets[tid] = sign * magnitude;
    });

    // tiny horizontal x-stagger so icons do not perfectly overlap on the same step
    const xStagger = {};
    trainIds.forEach((tid, idx) => {
        xStagger[tid] = (idx % 4) * 0.02; // very small shift in time units
    });

    // animation loop
    let step = 0;
    const intervalMs = 500; // animation speed

    const interval = setInterval(() => {
        // extend traces with this step's points
        const updatesX = trainIds.map(tid => [step + (xStagger[tid] || 0)]);
        const updatesY = trainIds.map(tid => {
            const raw = history[tid][step];
            return [ raw + (yOffsets[tid] || 0) ];
        });
        Plotly.extendTraces(containerId, { x: updatesX, y: updatesY }, trainIds.map((_,i) => i));

        // activate AI dots that start at this step
        actionStarts.forEach(ev => {
            if (ev.start === step) {
                if (!activeDots.some(d => d.id === ev.id)) {
                    activeDots.push({ id: ev.id, trainId: ev.trainId, info: ev.info });
                }
            }
        });

        // assemble images: train PNGs, collisions at this step, active AI dots
        const images = [];

        // train PNG icons (LARGER now)
        trainIds.forEach(tid => {
            // safety: if history doesn't have step (unlikely), skip
            if (!history[tid] || step >= history[tid].length) return;
            const pos = history[tid][step];
            images.push({
                source: "/static/train.png",
                x: step + (xStagger[tid] || 0),
                y: pos + (yOffsets[tid] || 0),
                xref: "x",
                yref: "y",
                // sizex is in x-axis units (time steps). sizey in y-axis units (position). Tweak these for visual size
                sizex:4.0,
                sizey: 330,
                xanchor: "center",
                yanchor: "middle",
                layer: "above"
            });
        });

        // collisions at this time
        if (collisionMap[step]) {
            collisionMap[step].forEach(pos => {
                images.push({
                    source: "data:image/svg+xml;utf8," + encodeURIComponent("<svg xmlns='http://www.w3.org/2000/svg' width='28' height='28'><circle cx='14' cy='14' r='14' fill='red'/></svg>"),
                    x: step,
                    y: pos,
                    xref: "x",
                    yref: "y",
                    sizex: 1.6,
                    sizey: 180,
                    xanchor: "center",
                    yanchor: "middle",
                    layer: "above"
                });
            });
        }

        // active orange dots travel with train
        activeDots.forEach(dot => {
            const tid = dot.trainId;
            if (!history[tid]) return;
            if (step >= history[tid].length) return;
            const pos = history[tid][step];
            images.push({
                source: svgDot("orange", 20),
                x: step + (xStagger[tid] || 0),
                y: pos + (yOffsets[tid] || 0),
                xref: "x",
                yref: "y",
                sizex: 1.0,
                sizey: 120,
                xanchor: "center",
                yanchor: "middle",
                layer: "above"
            });
        });

        // when the sim reaches the time of a pick, add a pinned annotation at the pick time+position.
        // Keep cumulativeAnnotations so they remain visible once added.
        Object.keys(picks).forEach(tid => {
            picks[tid].forEach((a, idx) => {
                const pickTime = Number(a[0]);
                // only proceed if sim time >= pickTime and not yet shown
                const key = `${tid}_${pickTime}_${idx}`;
                if (step >= pickTime && !pickShown[key]) {
                    // prefer actual history position at pickTime if available
                    const posAtPick = (history[tid] && history[tid].length > pickTime) ? history[tid][pickTime] : a[4];
                    const displayY = posAtPick + (yOffsets[tid] || 0);
                    const reduction = Math.abs((a[2] - a[3]) * 3.6).toFixed(1); // km/h
                    cumulativeAnnotations.push({
                        x: pickTime,
                        y: displayY,
                        xref: "x",
                        yref: "y",
                        text: `Train-${tid} â†“${reduction} km/h`,
                        showarrow: true,
                        arrowhead: 3,
                        ax: 0,
                        ay: -40 - (Number(tid) * 6) - (idx * 14),
                        font: { size: 12, color: "black" },
                        bgcolor: "rgba(255,255,255,0.95)",
                        bordercolor: "gray",
                        borderwidth: 1
                    });
                    pickShown[key] = true;
                }
            });
        });

        // update plot images and annotations (cumulativeAnnotations keeps previously shown picks)
        Plotly.relayout(containerId, { images: images, annotations: cumulativeAnnotations });

        step++;
        if (step >= maxSteps) {
            clearInterval(interval);
        }
    }, intervalMs);
}

/* ---------- Initialize (execute for whichever histories exist) ---------- */

{% if history_no_ai %}
animateGraph("plot-no-ai", {{ history_no_ai|tojson }}, {{ collisions_no_ai|tojson }}, [], "Without AI - Live");
{% endif %}

{% if history_prediction %}
animateGraph("plot-ai-prediction", {{ history_prediction|tojson }}, {{ predicted_collisions|tojson }}, [], "AI Prediction - Live");
{% endif %}

{% if history_prevention %}
animateGraph("plot-ai-prevention", {{ history_prevention|tojson }}, [], {{ ai_actions|tojson }}, "AI Prevention - Live");
{% endif %}

</script>
</body>
</html>
