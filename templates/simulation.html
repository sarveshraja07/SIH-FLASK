<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Simulation - AI Train Safety</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; margin: 0; background: #f9fafb; }
        nav { background:#2563eb; padding:15px; color:white; display:flex; justify-content:space-between; }
        nav ul { list-style:none; display:flex; gap:20px; margin:0; padding:0; }
        nav ul li a { color:white; text-decoration:none; font-weight:600; }
        .container { max-width:1000px; margin:40px auto; padding:20px; background:white; border-radius:10px; box-shadow:0 2px 8px rgba(0,0,0,0.1); }
        h1, h2 { color:#111827; }
        form { margin-bottom:20px; }
        label { font-weight:600; }
        button { background:#2563eb; color:white; border:none; padding:10px 15px; border-radius:5px; font-weight:600; cursor:pointer; }
        button:hover { background:#1e4fd1; }
    </style>
</head>
<body>
    <nav>
    <ul>
        <li><a href="/" class="{% if request.path == '/' %}active{% endif %}">Home</a></li>
        <li><a href="/simulation" class="{% if request.path == '/simulation' %}active{% endif %}">Simulation</a></li>
        <li><a href="/info" class="{% if request.path == '/info' %}active{% endif %}">Information</a></li>
        <li><a href="/about" class="{% if request.path == '/about' %}active{% endif %}">About</a></li>
    </ul>
</nav>

    <div class="container">
        <h1>AI Train Safety Simulation</h1>

        <form method="POST" action="/simulation">
            <label for="num_trains">Enter number of trains:</label>
            <input type="number" id="num_trains" name="num_trains" min="2" max="10" required>
            <button type="submit">Start Simulation</button>
        </form>

        {% if initial_trains %}
        <h2>Initial Conditions:</h2>
        <ul>
            {% for train in initial_trains %}
            <li>Train-{{ train.id }}: Position = {{ "%.2f"|format(train.position) }} m, Speed = {{ "%.2f"|format(train.speed * 3.6) }} km/h</li>
            {% endfor %}
        </ul>
        {% endif %}

        {% if history_no_ai %}
        <h2>Results Without AI (Actual Collisions)</h2>
        <div id="plot-no-ai" style="height:420px;"></div>
        {% endif %}

        {% if history_prediction %}
        <h2>Results With AI - Prediction (Before Action)</h2>
        <div id="plot-ai-prediction" style="height:420px;"></div>
        {% endif %}

        {% if history_prevention %}
        <h2>Results With AI - After Action</h2>
        <div id="plot-ai-prevention" style="height:420px;"></div>
        {% endif %}
    </div>

<script>
/* ---------- Utilities ---------- */
// create tiny colored SVG dot as data URL
function svgDot(color = "orange", size = 18) {
    const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='${size}' height='${size}'><circle cx='${size/2}' cy='${size/2}' r='${size/2}' fill='${color}'/></svg>`;
    return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
}

/* ---------- animateGraph ----------
   - history: { "1": [pos0,pos1,...], "2": [...] }
   - collisions: [ [time, position], ... ]
   - aiActions: [ [time, trainId, old_speed, new_speed, pos_at_time], ... ]
   Behavior:
     - train icons move each step
     - when ai action triggers (time==step) an orange dot activates for that train and then travels with train
     - annotations for first/middle/last per train are shown only when the train reaches (step >= pick_time)
     - small vertical offset applied per train index to reduce complete overlap at start
*/
function animateGraph(containerId, history, collisions=[], aiActions=[], title="") {
    const trainIds = Object.keys(history).sort((a,b)=>Number(a)-Number(b));
    if (trainIds.length === 0) return;
    const maxSteps = history[trainIds[0]].length;

    // initial traces
    const traces = trainIds.map(id => ({
        x: [], y: [], mode: "lines", line: { width: 2 }, name: `Train ${id}`
    }));

    Plotly.newPlot(containerId, traces, {
        title: title,
        xaxis: { title: "Time Step", range: [0, maxSteps] },
        yaxis: { title: "Position (m)" },
        margin: { t: 60 },
        showlegend: true,
        images: [],
        annotations: []
    });

    // group AI actions by train and sort by time
    const grouped = {};
    (aiActions || []).forEach(a => {
        const tid = String(a[1]);
        if (!grouped[tid]) grouped[tid] = [];
        grouped[tid].push(a);
    });
    Object.keys(grouped).forEach(tid => grouped[tid].sort((x,y)=>x[0]-y[0]));

    // prepare picks (first, middle, last) per train
    const picks = {}; // tid -> [actionObjs]
    Object.keys(grouped).forEach(tid => {
        const acts = grouped[tid];
        if (!acts || acts.length === 0) return;
        const arr = [];
        arr.push(acts[0]);
        if (acts.length > 2) arr.push(acts[Math.floor(acts.length/2)]);
        if (acts.length > 1) arr.push(acts[acts.length-1]);
        picks[tid] = arr;
    });

    // track which picks have had their annotation shown (so we show when train reaches or passes that time)
    const pickShown = {}; // string key "tid_time_idx" -> boolean

    // prepare action starts list (activate dot at action time)
    const actionStarts = (aiActions || []).map((a, idx) => ({
        id: idx,
        start: Number(a[0]),
        trainId: String(a[1]),
        info: a  // [time, trainId, old, new, pos]
    }));

    // active dots that travel with their train after activation
    const activeDots = []; // {id, trainId, info}

    // collision map by time
    const collisionMap = {};
    (collisions || []).forEach(c => {
        const t = Number(c[0]);
        if (!collisionMap[t]) collisionMap[t] = [];
        collisionMap[t].push(c[1]);
    });

    // small vertical offsets to avoid perfect overlap when trains start near each other
    // offset in meters; adjust factor if your position scale is different
    const yOffsets = {};
    trainIds.forEach((tid, idx) => {
        // small offset alternating up/down to keep them visually distinct
        const sign = (idx % 2 === 0) ? 1 : -1;
        const magnitude = 0.5 * Math.floor(idx/2); // multiple of 0.5m steps
        yOffsets[tid] = sign * magnitude;
    });

    // animation variables
    let step = 0;
    const intervalMs = 600; // adjust speed: smaller -> faster

    const interval = setInterval(() => {
        // extend traces with current positions
        const updateX = trainIds.map(_ => [step]);
        const updateY = trainIds.map(tid => {
            const val = history[tid][step];
            // apply y-offset so icons don't perfectly overlap when very close
            return [ val + (yOffsets[tid] || 0) ];
        });

        Plotly.extendTraces(containerId, { x: updateX, y: updateY }, trainIds.map((_,i)=>i));

        // activate any action that starts at this step
        actionStarts.forEach(ev => {
            if (ev.start === step) {
                // avoid duplicates: add only if not already in activeDots
                if (!activeDots.some(d => d.id === ev.id)) {
                    activeDots.push({ id: ev.id, trainId: ev.trainId, info: ev.info });
                }
            }
        });

        // build images array: train icons + active AI dots + collisions
        const images = [];

        // train icons (positioned with tiny width/height in plot units)
        trainIds.forEach((tid, idx) => {
            const pos = history[tid][step];
            images.push({
                source: "/static/train.png",
                x: step,
                y: pos + (yOffsets[tid] || 0),
                xref: "x",
                yref: "y",
                // sizex relative to time axis (in time-step units). Adjust for visual balance
                sizex: 1.4,
                sizey: Math.max(60, Math.abs( ( (history[tid][0]||pos) - pos )*0 + 100 )), // keep reasonable
                xanchor: "center",
                yanchor: "middle",
                layer: "above"
            });
        });

        // collisions at this step
        if (collisionMap[step]) {
            collisionMap[step].forEach(pos => {
                images.push({
                    source: "data:image/svg+xml;utf8," + encodeURIComponent("<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24'><circle cx='12' cy='12' r='12' fill='red'/></svg>"),
                    x: step,
                    y: pos,
                    xref: "x",
                    yref: "y",
                    sizex: 1.2,
                    sizey: 140,
                    xanchor: "center",
                    yanchor: "middle",
                    layer: "above"
                });
            });
        }

        // active AI dots travel with train
        activeDots.forEach(dot => {
            const tid = dot.trainId;
            if (!history[tid]) return;
            if (step >= history[tid].length) return;
            const pos = history[tid][step];
            images.push({
                source: svgDot("orange", 18),
                x: step,
                y: pos + (yOffsets[tid] || 0),
                xref: "x",
                yref: "y",
                sizex: 0.9,
                sizey: 90,
                xanchor: "center",
                yanchor: "middle",
                layer: "above"
            });
        });

        // annotations: show pick annotations only when train reaches/passes the pick time
        const annotations = [];
        Object.keys(picks).forEach(tid => {
            const arr = picks[tid];
            arr.forEach((a, idx) => {
                const pickTime = Number(a[0]);
                // only display annotation when step >= pickTime
                const key = `${tid}_${pickTime}_${idx}`;
                if (step >= pickTime && !pickShown[key]) {
                    // compute current position for the train at this step (if available)
                    const posNow = (history[tid] && history[tid][step] !== undefined) ? history[tid][step] + (yOffsets[tid] || 0) : a[4];
                    const reduction = ((a[2] - a[3]) * 3.6).toFixed(1);
                    annotations.push({
                        x: step,
                        y: posNow,
                        xref: 'x',
                        yref: 'y',
                        text: `Train-${tid} â†“${reduction} km/h`,
                        showarrow: true,
                        arrowhead: 3,
                        ax: 0,
                        ay: -40 - (Number(tid) * 6),
                        font: { size: 11, color: "black" },
                        bgcolor: "rgba(255,255,255,0.95)",
                        bordercolor: "gray",
                        borderwidth: 1
                    });
                    pickShown[key] = true;
                }
            });
        });

        // combine images and annotations with existing static picks (we're building annotations dynamically)
        Plotly.relayout(containerId, { images: images, annotations: annotations });

        step++;
        if (step >= maxSteps) {
            clearInterval(interval);
        }
    }, intervalMs);
}

/* ---------- Initialize graphs using Flask-provided data ---------- */

{% if history_no_ai %}
animateGraph("plot-no-ai", {{ history_no_ai|tojson }}, {{ collisions_no_ai|tojson }}, [], "Without AI - Live");
{% endif %}

{% if history_prediction %}
animateGraph("plot-ai-prediction", {{ history_prediction|tojson }}, {{ predicted_collisions|tojson }}, [], "AI Prediction - Live");
{% endif %}

{% if history_prevention %}
animateGraph(
    "plot-ai-prevention",
    {{ history_prevention|tojson }},
    [],                        // collisions not used here
    {{ ai_actions|tojson }},   // ai_actions format expected: [time, trainId, old_speed, new_speed, pos_at_time]
    "AI Prevention - Live"
);
{% endif %}

</script>
</body>
</html>
