<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Simulation - AI Train Safety</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; margin: 0; background: #f9fafb; }
        nav { background:#2563eb; padding:15px; color:white; display:flex; justify-content:space-between; }
        nav ul { list-style:none; display:flex; gap:20px; margin:0; padding:0; }
        nav ul li a { color:white; text-decoration:none; font-weight:600; }
        .container { max-width:1000px; margin:40px auto; padding:20px; background:white; border-radius:10px; box-shadow:0 2px 8px rgba(0,0,0,0.1); }
        h1, h2 { color:#111827; }
        form { margin-bottom:20px; }
        label { font-weight:600; }
        button { background:#2563eb; color:white; border:none; padding:10px 15px; border-radius:5px; font-weight:600; cursor:pointer; }
        button:hover { background:#1e4fd1; }
    </style>
</head>
<body>
    <nav>
    <ul>
        <li><a href="/" class="{% if request.path == '/' %}active{% endif %}">Home</a></li>
        <li><a href="/simulation" class="{% if request.path == '/simulation' %}active{% endif %}">Simulation</a></li>
        <li><a href="/info" class="{% if request.path == '/info' %}active{% endif %}">Information</a></li>
        <li><a href="/about" class="{% if request.path == '/about' %}active{% endif %}">About</a></li>
    </ul>
</nav>

    <div class="container">
        <h1>AI Train Safety Simulation</h1>

        <form method="POST" action="/simulation">
            <label for="num_trains">Enter number of trains:</label>
            <input type="number" id="num_trains" name="num_trains" min="2" max="10" required>
            <button type="submit">Start Simulation</button>
        </form>

        {% if initial_trains %}
        <h2>Initial Conditions:</h2>
        <ul>
            {% for train in initial_trains %}
            <li>Train-{{ train.id }}: Position = {{ "%.2f"|format(train.position) }} m, Speed = {{ "%.2f"|format(train.speed * 3.6) }} km/h</li>
            {% endfor %}
        </ul>
        {% endif %}

        {% if history_no_ai %}
        <h2>Results Without AI (Actual Collisions)</h2>
        <div id="plot-no-ai" style="height:420px;"></div>
        {% endif %}

        {% if history_prediction %}
        <h2>Results With AI - Prediction (Before Action)</h2>
        <div id="plot-ai-prediction" style="height:420px;"></div>
        {% endif %}

        {% if history_prevention %}
        <h2>Results With AI - After Action</h2>
        <div id="plot-ai-prevention" style="height:420px;"></div>
        {% endif %}
    </div>

<script>
// small helper to produce inline SVG dot
function svgDot(color = "orange", size = 20) {
    const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='${size}' height='${size}'><circle cx='${size/2}' cy='${size/2}' r='${size/2}' fill='${color}'/></svg>`;
    return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
}

function animateGraph(containerId, history, collisions=[], aiActions=[], title="") {
    const trainIds = Object.keys(history).sort((a,b)=>Number(a)-Number(b));
    if (trainIds.length === 0) return;
    const maxSteps = history[trainIds[0]].length;

    // initial traces
    const traces = trainIds.map(id => ({ x: [], y: [], mode: "lines", line: { width: 2 }, name: `Train ${id}` }));

    Plotly.newPlot(containerId, traces, {
        title: title,
        xaxis: { title: "Time Step", range: [0, maxSteps] },
        yaxis: { title: "Position (m)" },
        margin: { t: 60 },
        showlegend: true,
        images: [],
        annotations: []
    });

    // group ai actions and sort
    const grouped = {};
    (aiActions || []).forEach(a => {
        const tid = String(a[1]);
        if (!grouped[tid]) grouped[tid] = [];
        grouped[tid].push(a);
    });
    Object.keys(grouped).forEach(tid => grouped[tid].sort((x,y)=>x[0]-y[0]));

    // picks: first/mid/last per train
    const picks = {};
    Object.keys(grouped).forEach(tid => {
        const arr = grouped[tid];
        if (!arr || arr.length === 0) return;
        const sel = [arr[0]];
        if (arr.length > 2) sel.push(arr[Math.floor(arr.length/2)]);
        if (arr.length > 1) sel.push(arr[arr.length - 1]);
        picks[tid] = sel;
    });

    // pickShown controls when to actually show the pinned annotation (only show when train reaches pick time)
    const pickShown = {}; // key = `${tid}_${pickTime}_${idx}` -> bool

    // prepare actionStarts (activate moving dot at action time)
    const actionStarts = (aiActions || []).map((a, idx) => ({ id: idx, start: Number(a[0]), trainId: String(a[1]), info: a }));

    const activeDots = []; // {id, trainId, info}
    const collisionMap = {};
    (collisions || []).forEach(c => {
        const t = Number(c[0]);
        if (!collisionMap[t]) collisionMap[t] = [];
        collisionMap[t].push(c[1]);
    });

    // Larger vertical offsets (so trains don't hide each other). Alternating up/down and increasing spacing.
    const yOffsets = {};
    trainIds.forEach((tid, idx) => {
        const sign = (idx % 2 === 0) ? 1 : -1;
        const magnitude = 2.0 * Math.floor(idx/2); // 2 meter steps (increase if needed)
        yOffsets[tid] = sign * magnitude;
    });

    // horizontal micro-stagger so icons don't sit exact same x when close
    const xStagger = {};
    trainIds.forEach((tid, idx) => {
        xStagger[tid] = (idx % 3) * 0.05; // very small shift in x coordinate (time units)
    });

    let step = 0;
    const intervalMs = 600;

    const interval = setInterval(() => {
        // extend traces
        const updateX = trainIds.map(tid => [step + (xStagger[tid] || 0)]);
        const updateY = trainIds.map(tid => {
            const val = history[tid][step];
            return [ val + (yOffsets[tid] || 0) ];
        });
        Plotly.extendTraces(containerId, { x: updateX, y: updateY }, trainIds.map((_,i)=>i));

        // activate dots at their start times
        actionStarts.forEach(ev => {
            if (ev.start === step) {
                if (!activeDots.some(d => d.id === ev.id)) activeDots.push({ id: ev.id, trainId: ev.trainId, info: ev.info });
            }
        });

        // build images (train icons, AI dots, collision icons)
        const images = [];

        // train icons — made bigger (sizey increased)
        trainIds.forEach(tid => {
            const pos = history[tid][step];
            images.push({
                source: "/static/train.png",
                x: step + (xStagger[tid] || 0),
                y: pos + (yOffsets[tid] || 0),
                xref: "x",
                yref: "y",
                sizex: 1.8,     // wider
                sizey: 160,     // taller -> makes png bigger
                xanchor: "center",
                yanchor: "middle",
                layer: "above"
            });
        });

        // collisions that occur at this time
        if (collisionMap[step]) {
            collisionMap[step].forEach(pos => {
                images.push({
                    source: "data:image/svg+xml;utf8," + encodeURIComponent("<svg xmlns='http://www.w3.org/2000/svg' width='28' height='28'><circle cx='14' cy='14' r='14' fill='red'/></svg>"),
                    x: step,
                    y: pos,
                    xref: "x",
                    yref: "y",
                    sizex: 1.6,
                    sizey: 180,
                    xanchor: "center",
                    yanchor: "middle",
                    layer: "above"
                });
            });
        }

        // active AI dots travel with train
        activeDots.forEach(dot => {
            const tid = dot.trainId;
            if (!history[tid]) return;
            if (step >= history[tid].length) return;
            const pos = history[tid][step];
            images.push({
                source: svgDot("orange", 20),
                x: step + (xStagger[tid] || 0),
                y: pos + (yOffsets[tid] || 0),
                xref: "x",
                yref: "y",
                sizex: 1.0,
                sizey: 120,
                xanchor: "center",
                yanchor: "middle",
                layer: "above"
            });
        });

        // annotations: show pinned pick annotations (first/mid/last) but only once train reached the pick time
        const annotations = [];
        Object.keys(picks).forEach(tid => {
            picks[tid].forEach((a, idx) => {
                const pickTime = Number(a[0]);
                const pickPos = a[4];
                const key = `${tid}_${pickTime}_${idx}`;
                // show annotation only when simulation time >= pick time and not shown before
                if (step >= pickTime && !pickShown[key]) {
                    // compute arrow offset to reduce overlapping with other annotations
                    const ay = -40 - (Number(tid) * 6) - (idx * 16);
                    const reduction = Math.abs((a[2] - a[3]) * 3.6).toFixed(1);
                    annotations.push({
                        x: pickTime,
                        y: pickPos + (yOffsets[tid] || 0),
                        xref: 'x',
                        yref: 'y',
                        text: `Train-${tid} ↓${reduction} km/h`,
                        showarrow: true,
                        arrowhead: 3,
                        ax: 0,
                        ay: ay,
                        font: { size: 12, color: "black" },
                        bgcolor: "rgba(255,255,255,0.95)",
                        bordercolor: "gray",
                        borderwidth: 1
                    });
                    pickShown[key] = true;
                }
            });
        });

        Plotly.relayout(containerId, { images: images, annotations: annotations });

        step++;
        if (step >= maxSteps) {
            clearInterval(interval);
        }
    }, intervalMs);
}

/* Initialize graphs (Flask variables injected) */

{% if history_no_ai %}
animateGraph("plot-no-ai", {{ history_no_ai|tojson }}, {{ collisions_no_ai|tojson }}, [], "Without AI - Live");
{% endif %}

{% if history_prediction %}
animateGraph("plot-ai-prediction", {{ history_prediction|tojson }}, {{ predicted_collisions|tojson }}, [], "AI Prediction - Live");
{% endif %}

{% if history_prevention %}
animateGraph("plot-ai-prevention", {{ history_prevention|tojson }}, [], {{ ai_actions|tojson }}, "AI Prevention - Live");
{% endif %}

</script>
</body>
</html>
