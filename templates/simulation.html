<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Simulation - AI Train Safety</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; margin: 0; background: #f9fafb; }
        nav { background:#2563eb; padding:15px; color:white; display:flex; justify-content:space-between; }
        nav ul { list-style:none; display:flex; gap:20px; margin:0; padding:0; }
        nav ul li a { color:white; text-decoration:none; font-weight:600; }
        .container { max-width:1000px; margin:40px auto; padding:20px; background:white; border-radius:10px; box-shadow:0 2px 8px rgba(0,0,0,0.1); }
        h1, h2 { color:#111827; }
        form { margin-bottom:20px; }
        label { font-weight:600; }
        button { background:#2563eb; color:white; border:none; padding:10px 15px; border-radius:5px; font-weight:600; cursor:pointer; }
        button:hover { background:#1e4fd1; }
    </style>
</head>
<body>
    <nav>
    <ul>
        <li><a href="/" class="{% if request.path == '/' %}active{% endif %}">Home</a></li>
        <li><a href="/simulation" class="{% if request.path == '/simulation' %}active{% endif %}">Simulation</a></li>
        <li><a href="/info" class="{% if request.path == '/info' %}active{% endif %}">Information</a></li>
        <li><a href="/about" class="{% if request.path == '/about' %}active{% endif %}">About</a></li>
    </ul>
</nav>


    <div class="container">
        <h1>AI Train Safety Simulation</h1>

        <!-- ✅ Correct form action -->
        <form method="POST" action="/simulation">
            <label for="num_trains">Enter number of trains:</label>
            <input type="number" id="num_trains" name="num_trains" min="2" max="10" required>
            <button type="submit">Start Simulation</button>
        </form>

        {% if initial_trains %}
        <h2>Initial Conditions:</h2>
        <ul>
            {% for train in initial_trains %}
            <li>Train-{{ train.id }}: Position = {{ "%.2f"|format(train.position) }} m, Speed = {{ "%.2f"|format(train.speed * 3.6) }} km/h</li>
            {% endfor %}
        </ul>
        {% endif %}

        {% if history_no_ai %}
        <h2>Results Without AI (Actual Collisions)</h2>
        <div id="plot-no-ai" style="height:400px;"></div>
        {% endif %}

        {% if history_prediction %}
        <h2>Results With AI - Prediction (Before Action)</h2>
        <div id="plot-ai-prediction" style="height:400px;"></div>
        {% endif %}

        {% if history_prevention %}
        <h2>Results With AI - After Action</h2>
        <div id="plot-ai-prevention" style="height:400px;"></div>
        {% endif %}
    </div>

    <script>
    // Helper: create SVG data URL for a colored dot
    function svgDot(color = "orange", size = 20) {
        const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='${size}' height='${size}'><circle cx='${size/2}' cy='${size/2}' r='${size/2}' fill='${color}'/></svg>`;
        return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
    }

    function animateGraph(containerId, history, collisions=[], aiActions=[], title="") {
        // history: { "1": [pos_t0, pos_t1, ...], "2": [...] }
        // collisions: [ [time, position], ... ]  (time numeric)
        // aiActions: [ [time, trainId, old_speed, new_speed, position_at_time], ... ]

        let trainIds = Object.keys(history);
        if (trainIds.length === 0) return;
        let maxSteps = history[trainIds[0]].length;

        // initial empty traces for each train
        let traces = trainIds.map(trainId => ({
            x: [],
            y: [],
            mode: "lines",
            line: { width: 2 },
            name: `Train ${trainId}`
        }));

        Plotly.newPlot(containerId, traces, {
            title: title,
            xaxis: { title: "Time Step", range: [0, maxSteps] },
            yaxis: { title: "Position (m)" },
            margin: { t: 60 },
            showlegend: true,
            images: [],
            annotations: []
        });

        // Group AI actions per train and keep chronological order
        let groupedActions = {};
        aiActions.forEach(a => {
            let t = a[1].toString();
            if (!groupedActions[t]) groupedActions[t] = [];
            groupedActions[t].push(a);
        });
        for (let t in groupedActions) {
            groupedActions[t].sort((a,b) => a[0] - b[0]);
        }

        // Pre-calc annotations: pick first, middle, last action per train
        let finalAnnotations = [];
        for (let trainId in groupedActions) {
            let actions = groupedActions[trainId];
            let total = actions.length;
            if (total === 0) continue;
            // pick indices
            let picks = [];
            picks.push(actions[0]);
            if (total > 2) picks.push(actions[Math.floor(total/2)]);
            if (total > 1) picks.push(actions[total-1]);

            // create annotation for each pick
            picks.forEach(a => {
                // a = [time, trainId, old_speed (m/s), new_speed (m/s), pos_at_time]
                let reduction = ((a[2] - a[3]) * 3.6).toFixed(1); // km/h
                finalAnnotations.push({
                    x: a[0],
                    y: a[4],
                    xref: 'x',
                    yref: 'y',
                    text: `Train-${a[1]} ↓${reduction} km/h`,
                    showarrow: true,
                    arrowhead: 3,
                    ax: 0,
                    ay: -40 - (Number(a[1]) * 6),
                    font: { size: 11, color: "black" },
                    bgcolor: "rgba(255,255,255,0.9)",
                    bordercolor: "gray",
                    borderwidth: 1
                });
            });
        }

        // Prepare AI action start events (so we can "activate" a moving dot when action time reached)
        // Each active dot will then track the train position from action time to end.
        let actionStarts = aiActions.map((a, idx) => ({
            id: idx,
            start: Number(a[0]),
            trainId: a[1].toString(),
            info: a  // store original action tuple for reference
        }));

        // Keep active dots (those whose start <= current step)
        let activeDots = []; // entries: {id, trainId, info}

        // Also precompute collision map by time for fast lookup
        let collisionMap = {};
        (collisions || []).forEach(c => {
            const time = Number(c[0]);
            if (!collisionMap[time]) collisionMap[time] = [];
            collisionMap[time].push(c[1]);
        });

        // animation loop
        let step = 0;
        const intervalMs = 700; // speed of animation (adjust if needed)

        let interval = setInterval(() => {
            // update traces: extend with this step's datapoints
            let updatesX = trainIds.map(_ => [step]);
            let updatesY = trainIds.map(trainId => [ history[trainId][step] ]);

            Plotly.extendTraces(containerId, { x: updatesX, y: updatesY }, trainIds.map((_,i) => i));

            // activate any new dots whose start == step
            actionStarts.forEach(ev => {
                if (ev.start === step) {
                    activeDots.push({ id: ev.id, trainId: ev.trainId, info: ev.info });
                }
            });

            // build images: train icons + collision icons + active AI dots
            let images = [];

            // train icons (small, track along train)
            trainIds.forEach(trainId => {
                let pos = history[trainId][step];
                images.push({
                    source: "/static/train.png",
                    x: step,
                    y: pos,
                    xref: "x",
                    yref: "y",
                    sizex: 1.6,   // horizontal size in x-units (time steps)
                    sizey: 120,   // vertical size in y-units (position scale)
                    xanchor: "center",
                    yanchor: "middle",
                    layer: "above"
                });
            });

            // collision icons at their times/positions (they appear only on that step)
            if (collisionMap[step]) {
                collisionMap[step].forEach(pos => {
                    images.push({
                        source: "data:image/svg+xml;utf8," + encodeURIComponent("<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24'><circle cx='12' cy='12' r='12' fill='red'/></svg>"),
                        x: step,
                        y: pos,
                        xref: "x",
                        yref: "y",
                        sizex: 1.2,
                        sizey: 150,
                        xanchor: "center",
                        yanchor: "middle",
                        layer: "above"
                    });
                });
            }

            // active AI dots: these travel with their train after activation
            activeDots.forEach(dot => {
                const trainId = dot.trainId;
                // avoid out-of-range (safety)
                if (!history[trainId] || step >= history[trainId].length) return;
                const pos = history[trainId][step];
                images.push({
                    source: svgDot("orange", 18),
                    x: step,
                    y: pos,
                    xref: "x",
                    yref: "y",
                    sizex: 0.8,
                    sizey: 120,
                    xanchor: "center",
                    yanchor: "middle",
                    layer: "above"
                });
            });

            // also, if you'd like, show small marker when action occurs exactly at this step (redundant with activeDots startup)
            // (We already activate dots when start===step, so they will appear here)

            // relayout with new set of images and annotations (annotations are static picks)
            Plotly.relayout(containerId, { images: images, annotations: finalAnnotations });

            step++;
            if (step >= maxSteps) {
                clearInterval(interval);
            }
        }, intervalMs);
    }

    // Initialize three animations depending on which histories are present
    {% if history_no_ai %}
    animateGraph("plot-no-ai", {{ history_no_ai|tojson }}, {{ collisions_no_ai|tojson }}, [], "Without AI - Live");
    {% endif %}

    {% if history_prediction %}
    animateGraph("plot-ai-prediction", {{ history_prediction|tojson }}, {{ predicted_collisions|tojson }}, [], "AI Prediction - Live");
    {% endif %}

    {% if history_prevention %}
    // Pass ai_actions as list of [time, trainId, old_speed, new_speed, pos_at_time]
    animateGraph("plot-ai-prevention", {{ history_prevention|tojson }}, [], {{ ai_actions|tojson }}, "AI Prevention - Live");
    {% endif %}
    </script>
</body>
</html>
